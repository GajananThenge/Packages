{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## TO DO:\n",
    "https://www.analyticsvidhya.com/blog/2016/01/python-tutorial-list-comprehension-examples/\n",
    "\n",
    "https://martin-thoma.com/functional-programming-in-python/"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 1. Given: lists = [[1, 2, 3, 4], [5, 6, 7, 8], [8, 5, 2, 1]]\n",
    "    \n",
    "   Output: [24,1680,80]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import operator\n",
    "from functools import reduce\n",
    "multiply = operator.mul\n",
    "\n",
    "result = [reduce(multiply, a_list) for a_list in lists]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 2.  Flatten the 2d array\n",
    "ini_list = [[1, 2, 3], \n",
    "            [3, 6, 7], \n",
    "            [7, 5, 4]] "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# using list comprehension \n",
    "flatten_list = [j for sub in ini_list for j in sub] \n",
    "  \n",
    "# printing flatten_list \n",
    "print (\"final_result\", str(flatten_list)) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Generator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<generator object my_first_gen at 0x0000021325DAE390>\n"
     ]
    }
   ],
   "source": [
    "\n",
    "def my_first_gen(n):\n",
    "    for i in range(n):\n",
    "        yield i\n",
    "\n",
    "print(my_first_gen(3))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n"
     ]
    }
   ],
   "source": [
    "gen = my_first_gen(3) #Initialize the generator\n",
    "print(next(gen))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n"
     ]
    }
   ],
   "source": [
    "print(next(gen))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### map,filter,reduce"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
     ]
    }
   ],
   "source": [
    "numbers = list(range(10))\n",
    "squares = map(lambda x: x**2, numbers)\n",
    "print(list(squares))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### When to use Generator expression and List comprehensions?\n",
    "#### Consider following functions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sum_list(N):\n",
    "    return sum([x for x in range(N)])\n",
    "def sum_gen(N):\n",
    "    return sum((x for x in range(N)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Execute These functions for different values of N"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Time for LC: \n",
      "4.98 ms ± 380 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n",
      "Time for Generator: \n",
      "6.45 ms ± 19.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n",
      "Time for LC: \n",
      "1.08 s ± 6.14 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n",
      "Time for Generator: \n",
      "831 ms ± 2.47 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n",
      "Time for LC: \n",
      "11.5 s ± 341 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n",
      "Time for Generator: \n",
      "8.51 s ± 66.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n"
     ]
    }
   ],
   "source": [
    "N=100000 #100\n",
    "print(\"Time for LC: \")\n",
    "%timeit sum_list(N)\n",
    "\n",
    "print(\"Time for Generator: \")\n",
    "%timeit sum_gen(N)\n",
    "\n",
    "N=10000000# 10Mn\n",
    "print(\"Time for LC: \")\n",
    "%timeit sum_list(N)\n",
    "\n",
    "print(\"Time for Generator: \")\n",
    "%timeit sum_gen(N)\n",
    "\n",
    "\n",
    "N=100000000 # 100Mn\n",
    "\n",
    "print(\"Time for LC: \")\n",
    "%timeit sum_list(N)\n",
    "\n",
    "print(\"Time for Generator: \")\n",
    "%timeit sum_gen(N)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Conclusion\n",
    "* For small N, Generator Expression are relatively slower than List Comprehensions. This is because of high multiple calls are required in Generator Expression but List Comprehensions doesn’t require much space in memory.\n",
    "* For moderate N, Generator Expression perform almost the same as List Comprehensions. GE requires high number of calls and List Comprehensions needs large memory block.\n",
    "* For very high N, generators are drastically powerful as List Comprehensions takes ~70 times of the time taken by GE. This is because List Comprehensions uses up a very large chunk of RAM and processing becomes very slow."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
