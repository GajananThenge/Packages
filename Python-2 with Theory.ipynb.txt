{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Iterator,generator"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Iterator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Generator"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* A generator is an iterator but it returns a single value at a time\n",
    "* It can be created using yield keyword\n",
    "* Whenever next is called, generator executes till it encounters a yield statement."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<generator object my_first_gen at 0x0000021325DAE390>\n"
     ]
    }
   ],
   "source": [
    "def my_first_gen(n):\n",
    "    for i in range(n):\n",
    "        yield i\n",
    "\n",
    "print(my_first_gen(3))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n"
     ]
    }
   ],
   "source": [
    "gen = my_first_gen(3) #Initialize the generator\n",
    "print(next(gen))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n"
     ]
    }
   ],
   "source": [
    "print(next(gen))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Consider following functions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sum_list(N):\n",
    "    return sum([x for x in range(N)])\n",
    "def sum_gen(N):\n",
    "    return sum((x for x in range(N)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Execute These functions for different values of N"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Time for LC: \n",
      "4.98 ms ± 380 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n",
      "Time for Generator: \n",
      "6.45 ms ± 19.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n",
      "Time for LC: \n",
      "1.08 s ± 6.14 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n",
      "Time for Generator: \n",
      "831 ms ± 2.47 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n",
      "Time for LC: \n",
      "11.5 s ± 341 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n",
      "Time for Generator: \n",
      "8.51 s ± 66.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n"
     ]
    }
   ],
   "source": [
    "N=100000 #100\n",
    "print(\"Time for LC: \")\n",
    "%timeit sum_list(N)\n",
    "\n",
    "print(\"Time for Generator: \")\n",
    "%timeit sum_gen(N)\n",
    "\n",
    "N=10000000# 10Mn\n",
    "print(\"Time for LC: \")\n",
    "%timeit sum_list(N)\n",
    "\n",
    "print(\"Time for Generator: \")\n",
    "%timeit sum_gen(N)\n",
    "\n",
    "\n",
    "N=100000000 # 100Mn\n",
    "\n",
    "print(\"Time for LC: \")\n",
    "%timeit sum_list(N)\n",
    "\n",
    "print(\"Time for Generator: \")\n",
    "%timeit sum_gen(N)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Conclusion\n",
    "* For small N, Generator Expression are relatively slower than List Comprehensions. This is because of high multiple calls are required in Generator Expression but List Comprehensions doesn’t require much space in memory.\n",
    "* For moderate N, Generator Expression perform almost the same as List Comprehensions. GE requires high number of calls and List Comprehensions needs large memory block.\n",
    "* For very high N, generators are drastically powerful as List Comprehensions takes ~70 times of the time taken by GE. This is because List Comprehensions uses up a very large chunk of RAM and processing becomes very slow."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# map,filter,Reduce"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### map\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###  reduce()\n",
    "* reduce() is found in functools module\n",
    "* sed to reduce a list of values to a single output"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "find sum of first n values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Comprehensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### List Comprehesions\n",
    "\n",
    "* LC will always return a result, whether you use the result or nor.\n",
    "* The iteration and conditional expressions can be nested with multiple instances.\n",
    "* Even the overall LC can be nested inside another LC.\n",
    "* Multiple variables can be iterated and manipulated at same time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
